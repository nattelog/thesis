\chapter{Method}
\label{cha:method}

\iffalse
In this chapter, the method is described in a way which shows how the
work was actually carried out. The description must be precise and
well thought through. Consider the scientific term
replicability. Replicability means that someone reading a scientific
report should be able to follow the method description and then carry
out the same study and check whether the results obtained are
similar. Achieving replicability is not always relevant, but precision
and clarity is.

Sometimes the work is separated into different parts, e.g.  pre-study,
implementation and evaluation. In such cases it is recommended that
the method chapter is structured accordingly with suitable named
sub-headings.
\fi

The aim of this study is fundamentally to compare a single-threaded
implementation to a multi-threaded implementation of an embedded software
application. The application is of a reactive nature and is relevant to modern
industry. Previous attempts have been made to prove how certain programming
languages perform better when used in a reactive context. Terber
\cite{terber2017function} discusses the lack of function-oriented software
decomposition for reactive software. With an industrial application as context,
he replaces legacy code with code written in the \textit{Cèu} programming
language, reaching the conclusion that Cèu preserves fundamental software
engineering principles and is at the same time able to fullfill resource
limitations in the system. Jagadeesan et al \cite{jagadeesan1996formal}
performs a similar study but with a different language: \textit{Esterel}. They
reimplement a component in a telephone switching system and reach the
conclusion that Esterel is better suited for analysis and verification for
reactive systems.

The main approach this study will undertake to answer its questions is 1) to
create a specification of a system that will be implemented, 2) perform the
implementation with the chosen libraries and platforms, 3) test the
implementations, 4) apply the metrics and 5) perform evaluation of the metrics.

\section{Pre-study}

A major literature study will be conducted prior and during the implementation.
The theoretical framework will be vindicated in this phase to support claims
and form a general direction of the entire study. Multiple databases will be
queried in order to find interesting material from previous research. Mainly
the online library hosted by \textit{Linköping
University}\footnote{\url{www.bibl.liu.se}} will be used since it allow access
to material otherwise unviewable due to institutional login requirements. Query
results from this library is a collection of query results from other research
databases such as \textit{ACM Digital Library}\footnote{\url{dl.acm.org}},
\textit{ProQuest Ebook Central}\footnote{\url{ebookcentral.proquest.com}} and
\textit{IEEE Xplore Digital Library}\footnote{\url{ieeexplore.ieee.org}}; so it
acts as a gateway to a global collection of scientific research.

The \textit{three-pass approach} presented by Keshav \cite{keshav2007read} will
be used as a basic approach to find interesting material. It helps the reader
grasp the paper's content in three \textit{passes}. The first pass' purpose is
to give the reader an overview of the paper. The title, abstract, introduction,
headings, sub-headings, conclusions and references are read. This information
should help the reader understand the paper's category and context and help
decide whether to continue read this paper or leave it. If the reader choose to
continue read it, the second pass starts. Here the paper is read more
thoroughly. The figures and diagrams are examined and after this pass the
reader should be able to summarize the paper, with leading evidence, to someone
else. The purpose of the third pass is to fully understand the paper. By making
the same assumptions as the author, the paper is virtually re-created. It helps
identify the true innovations of the paper, as well as the hidden failures.

\section{Creating a specification}

This very same method will be used in this study. A multi-sensor monitor
application will be specified. Its basic purpose is to listen for data from
different sensors and publish it to a web service. The application will be
developed on a Raspberry Pi device with an ARM processor. Each sensor will be
connected to the device's \textit{GPIO} ports and the software will poll data
in specific time intervals. The application will have a set of events which are
called when a specific timeout or request is issued.

\begin{itemize}
\item
  $DATA\_READY$: This event is dispatched when sensor data is ready to be read.
The data is a tuple consisting of the sensor ID and its current value: $<ID,
value>$.
\item
  $SYSTEM\_STATUS$: This event is dispatched from a remote client on the web.
\end{itemize}

Following is a description of the general properties of the system.

\begin{enumerate}
\item
  When event $DATA\_READY$ occurs,
\begin{enumerate}
\item
  If a remote client exists, send the data to it.
\item
  Do nothing.
\end{enumerate}
\item
  When event $SYSTEM\_STATUS$ occurs,
\begin{enumerate}
\item
  If the last time $DATA\_READY$ was dispatched is outside the accepted time
frame, send $STATUS\_NOT\_OK$ to the remote client.
\item
  Send $STATUS\_OK$ to the remote client.
\end{enumerate}
\end{enumerate}

\section{Implementation}

Two different implementations written in C++ will be tested in this study: one
using the \textit{libuv} library, and one with no specific third party library.
The first implementation will utilize the \textit{event-loop} inside the libuv
library to handle timers and event callbacks. The second implementation will
instead create new threads to handle events.

\section{Testing the implementation}

A testing environment will be created. This will include actual hardware
sensors for humidity and temperature that will be connected to the Raspberry Pi
device. A web client will also be developed to be able to communicate with the
device to receive sensor data and request system status. Multiple test cases
will be written in both software and as a specification for higher level
integration tests.

\section{Applying the metrics}

Maintainability will be the main software metric to apply on the
implementations. To measure performance, a benchmark test will be done were a
large amount of sensor data polls and remote client requests will be issued.

\section{Evaluate the metrics}

The values received from both the software metric analysis and the performance
analysis will be compared.
